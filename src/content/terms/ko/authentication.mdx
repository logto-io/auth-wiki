---
title: 인증 (Authentication, AuthN)
tags: [authentication]
description: "인증은 신원 소유권(예: 사용자 또는 서비스)을 확인하는 과정입니다. 이는 신원 및 접근 관리 (IAM) 시스템의 기초이며, 애플리케이션과 서비스를 보호하는 데 필수적입니다."
---

## 인증 (Authentication, AuthN)이란 무엇인가?

**인증 (Authentication, AuthN)**은 소프트웨어에 내장된 메커니즘으로, 사용자가 자격 증명을 기반으로 리소스에 접근하기 전에 사용자를 식별하는 것입니다. 예를 들어, 가장 일반적인 로그인 방법은 이메일과 비밀번호를 사용하는 것입니다. 시스템은 이러한 자격 증명을 사용하여 사용자가 올바른 신원을 가지고 있는지를 확인합니다.

<Ref slug="iam" />의 맥락에서 인증은 신원 소유권을 확인하는 것이지 그 뒤에 있는 사람이나 엔티티를 식별하는 것이 아닙니다. 예를 들어, 가족 구성원이 당신의 자격 증명을 사용하여 로그인하면 그들은 당신이 아니지만 시스템은 그들을 동일한 신원으로 인식합니다.

신원은 사용자뿐만 아니라 서비스나 장치를 나타낼 수도 있습니다. 예를 들어, 한 서비스가 다른 서비스에 <Ref slug="api-key" />를 사용하여 자신을 인증할 수 있습니다.

기술이 발전함에 따라 인증 방법은 더욱 정교하고 다학문적으로 발전했습니다. 이 용어는 기술적으로 들릴 수 있지만, 모든 애플리케이션과 소프트웨어가 사용자 정보를 안전하게 보호하고 시스템에 대한 접근을 보장하기 위해 인증에 의존하기 때문에 사이버 보안의 핵심 개념입니다.

## 인증 (Authentication, AuthN) 요소

**인증 (AuthN) 요소**는 인증 과정에서 사용자의 신원을 확인하는 데 사용되는 증거의 범주입니다. 이 요소들은 시스템이나 리소스에 접근할 수 있는 권한이 있는 사용자만이 접근할 수 있도록 보장합니다. 이러한 요소들은 일반적으로 "인증의 세 가지 요소"라고 불리는 세 가지 주요 유형으로 나뉩니다.

- **지식 요소**: 당신이 알고 있는 것 (예: 비밀번호, PIN)
- **소지 요소**: 당신이 가지고 있는 것 (예: 스마트폰, 보안 토큰)
- **고유 요소**: 당신 자신인 것 (예: 지문, 얼굴 인식)

다음은 두 가지 예입니다:

<Ref slug="mfa" />는 보안을 강화하기 위해 여러 요소를 결합하는 일반적인 관행입니다. 예를 들어, 은행 계좌에 로그인할 때 비밀번호(지식 요소)와 인증 앱에서 제공하는 일회용 코드(소지 요소)를 제공해야 할 수 있습니다.

<Ref slug="passkey" />는 여러 요소를 결합할 수 있으며 피싱 공격에 저항할 수 있는 현대적인 인증 요소입니다.

## 일반적인 인증 (Authentication, AuthN) 유형은 무엇인가요?
주요 구성 요소와 인증 요소를 다룬 후, 이제 인증 유형으로 넘어가겠습니다. 시스템과 제품은 다양한 인증 방법을 사용하며, 이러한 방법들은 정의와 사용자가 이해하는 방식에서 겹칠 수 있습니다. 인증 방법을 선택할 때는 제품의 필요에 집중하고 사용자 경험과 보안의 균형을 맞추는 것이 중요합니다.

### 비밀번호 인증

**비밀번호 인증**은 시스템이나 애플리케이션에 접근할 때 사용자의 신원을 확인하는 데 널리 사용되는 방법입니다. 사용자는 예를 들어 이메일 주소나 사용자 이름, 전화번호와 같은 고유 식별자를 제공하고, 사용자만 알고 있는 비밀 문자열인 비밀번호를 제공해야 합니다.

이 과정은 사용자가 로그인 양식에 이메일과 비밀번호를 입력하는 것으로 시작됩니다. 시스템은 이러한 자격 증명을 등록된 사용자 데이터베이스와 대조합니다. 자격 증명이 일치하면 사용자는 접근 권한을 얻고, 그렇지 않으면 접근이 거부됩니다. 인증이 성공하면 시스템은 사용자의 로그인 상태를 유지하기 위해 세션을 생성하거나 토큰을 발급할 수 있습니다.

이 방법은 간단하고 널리 지원되어 사용자가 이해하고 사용하기 쉽습니다. 그러나 피싱, 무차별 대입 공격, 데이터 유출을 통해 비밀번호가 손상될 수 있는 문제도 있습니다. 또한, 사용자는 다양한 서비스에 대해 여러 비밀번호를 기억하는 것이 불편할 수 있습니다. 이러한 문제를 해결하기 위해 이메일 및 비밀번호 인증은 종종 추가 검증 레이어를 추가하는 이중 인증(2FA)과 같은 보안 조치로 강화되거나, 강력하고 고유한 비밀번호를 안전하게 관리하도록 권장됩니다.

비록 이러한 문제들이 있지만, 이메일 및 비밀번호 인증은 여전히 신원 확인을 위한 기초적인 방법으로, 보안을 강화하기 위해 추가적인 조치와 결합되어 사용됩니다.

### 비밀번호 없는 인증

비밀번호 없는 인증은 비밀번호에 의존하지 않는 모든 사용자 인증 방법을 광범위하게 이해할 수 있습니다. **비밀번호 없는 인증**은 전통적인 비밀번호 없이 사용자의 신원을 확인하는 방법입니다. 대신, 이메일이나 SMS, 인증 앱을 통한 <Ref slug="otp" /> 전송, 지문이나 얼굴 인식과 같은 생체 인증, 사용자의 이메일로 전송된 매직 링크, 장치에 저장된 패스키, Google이나 Facebook과 같은 제공자의 계정을 사용하는 소셜 로그인과 같은 대체 기술과 요소를 사용하여 사용자를 안전하게 인증합니다.

이 접근 방식은 피싱, 무차별 대입 공격, 유출과 같은 비밀번호와 관련된 위험을 줄임으로써 보안을 향상시킵니다. 또한 비밀번호를 기억하고 관리할 필요성을 없애 사용자 경험을 개선하고, 비밀번호 재설정 요청을 줄여 유지보수 비용을 낮춥니다.

### 소셜 인증

**소셜 인증**은 사용자가 Google, Facebook, Twitter, LinkedIn과 같은 소셜 미디어 또는 신원 제공자 플랫폼의 기존 자격 증명을 사용하여 애플리케이션이나 웹사이트에 로그인할 수 있도록 하는 방법입니다. 각 애플리케이션에 대해 새로운 사용자 이름과 비밀번호를 생성하는 대신, 사용자는 이미 신뢰하는 계정을 사용하여 인증할 수 있습니다.

사용자가 소셜 로그인 옵션을 선택하면, 선택한 플랫폼으로 리디렉션되어 자격 증명을 확인합니다. 인증이 완료되면 플랫폼은 애플리케이션에 토큰이나 사용자 정보(예: 이름, 이메일 주소, 프로필 사진)를 제공하여 신원을 확인합니다. 이 과정은 안전하며 종종 사용자에게 로그인 경험을 단순화합니다.

소셜 인증은 사용자에게 마찰을 줄이고, <Ref slug="identity-provider" />의 인프라를 활용하여 보안을 개선하며, 애플리케이션이 검증된 사용자 데이터를 빠르게 수집할 수 있도록 합니다. 이는 접근 용이성과 소셜 플랫폼과의 통합이 우선인 애플리케이션에서 특히 인기가 있습니다.

### 다중 요소 인증

<Ref slug="mfa" />는 사용자가 두 개 이상의 서로 다른 인증 요소를 사용하여 신원을 확인해야 하는 보안 프로세스입니다. 이러한 요소들은 앞서 언급한 인증 요소와 같이 일반적으로 세 가지 범주로 나뉩니다: 당신이 알고 있는 것, 당신이 가지고 있는 것, 당신 자신인 것.

여러 요소를 결합함으로써 MFA는 보안을 크게 강화합니다. 비밀번호와 같은 한 요소가 손상되더라도 추가 검증 레이어가 있어 비인가 사용자가 접근하기가 훨씬 어렵습니다.

MFA는 온라인 뱅킹, 기업 네트워크, 금융적으로 민감한 제품, 클라우드 서비스와 같이 높은 수준의 보안이 필요한 시스템에서 널리 사용됩니다. 이는 인증 방법이라기보다는 인증을 위한 보안 조치로 더 정확하게 설명됩니다.

### **생체 인증**

**생체 인증**은 **고유한 신체적 또는 행동적 특성**을 기반으로 사용자의 신원을 확인하는 보안 프로세스입니다. 이러한 특성은 지문, 얼굴 특징, 음성 패턴과 같이 매우 개별적이며 복제하기 어려워 이 방법을 안전하고 신뢰할 수 있게 만듭니다.

이 과정은 사용자의 생체 데이터를 캡처하고 참조로 안전하게 저장하는 등록으로 시작됩니다. 인증 중에 시스템은 사용자의 실시간 생체 데이터를 캡처하고 저장된 참조와 비교합니다. 데이터가 일치하면 접근이 허용되고, 그렇지 않으면 거부됩니다.

이 방법은 사용자가 비밀번호를 기억하거나 물리적 토큰을 휴대할 필요가 없기 때문에 편리합니다. 이는 스마트폰, 은행 앱, 보안 시설, 의료 시스템과 같은 애플리케이션에서 빠르고 신뢰할 수 있으며 사용자 친화적인 접근을 제공하기 위해 널리 사용됩니다.

### 신원 제공자 (IdP)를 통한 엔터프라이즈 싱글 사인온 (SSO)

<Ref slug="enterprise-sso" />는 사용자가 한 번 로그인하면 다시 인증할 필요 없이 여러 애플리케이션이나 서비스에 접근할 수 있도록 합니다. IdP는 사용자 신원을 관리하고 인증을 처리하는 신뢰할 수 있는 서비스입니다.

작동 방식은 다음과 같습니다:
1. 사용자가 IdP(예: Google, Azure AD)를 통해 로그인합니다.
2. IdP는 사용자를 인증하고 토큰이나 어설션을 발급합니다.
3. 토큰은 추가 로그인 없이 접근을 허용하기 위해 다른 연결된 앱이나 서비스와 공유됩니다.

이 설정은 사용자 접근을 단순화하면서 보안을 위해 신원 관리를 중앙 집중화합니다.

### 기계 간 인증

<Ref slug="machine-to-machine" /> 인증은 인간의 개입 없이 서로 통신하는 장치, 애플리케이션 또는 서비스의 신원을 확인하는 과정입니다. 이는 IoT(사물 인터넷) 환경, API 또는 클라우드 기반 서비스에서 기계 간의 안전한 상호 작용을 보장합니다.

M2M 인증에서는 전통적인 사용자 인증과 같은 사용자 이름과 비밀번호 대신, 기계는 <Ref slug="oauth-2.0" />와 같은 API 키, 인증서 또는 토큰과 같은 안전한 자격 증명에 의존합니다. 이러한 자격 증명은 기계나 서비스가 다른 기계나 리소스에 접근할 권한이 있는지를 확인하는 데 사용됩니다.

예를 들어, 모바일 앱이 사용자 데이터를 검색하기 위해 클라우드 서버와 통신할 때, 서버는 API 키나 토큰을 사용하여 앱이 합법적인 클라이언트인지 확인합니다. 마찬가지로, IoT에서는 스마트 온도 조절기나 웨어러블 장치가 인증서나 안전한 토큰을 사용하여 제어 시스템이나 데이터 서버와 인증합니다.

M2M 인증은 특히 민감한 정보가 교환되는 환경에서 자동화된 시스템의 데이터 보안과 신뢰를 보장하는 데 중요합니다.

## 인증 (Authentication, AuthN)을 구현하기 위한 모범 사례와 주요 원칙은 무엇인가요?

인증 기능을 구현할 때는 주요 원칙에 집중해야 합니다. OAuth 2.0 또는 OpenID Connect와 같은 신뢰할 수 있는 프로토콜을 사용하고 민감한 데이터를 암호화하는 것이 강력히 권장됩니다. 또한, 소셜 로그인, 패스키와 같은 비밀번호 없는 방법, 사용자 이름/비밀번호, 생체 인증 또는 SSO와 같은 다양한 인증 방법을 지원하는 옵션을 제공하면 시스템이 다양한 사용자 요구를 충족할 수 있습니다.

## OIDC, SAML 및 OAuth 2.0에서의 인증 (Authentication, AuthN)

자체 인증 시스템을 구축하는 대신, 보안 전문가에 의해 검토되고 테스트된 기존의 프레임워크와 프로토콜을 사용하는 것이 좋습니다. 인증이 수행되어야 하는 방법을 정의하는 다양한 인증 프레임워크와 프로토콜이 있습니다. 일반적인 두 가지는 다음과 같습니다:

- <Ref slug="openid-connect" />: 인증 기능을 추가한 <Ref slug="oauth-2.0" /> 위에 구축된 신원 레이어입니다. 이는 비교적 현대적이며 새로운 애플리케이션에 널리 사용됩니다.
- <Ref slug="saml" />: 당사자 간 인증 및 권한 부여 데이터를 교환하기 위한 프로토콜입니다. 이는 주로 기업 환경에서 사용됩니다.

프레임워크의 선택은 사용 사례와 요구 사항에 따라 다릅니다. 새로운 애플리케이션의 경우, 현대적인 설계와 <Ref slug="jwt" /> 지원으로 인해 OIDC가 권장됩니다.

그러나 이러한 프로토콜을 직접 다루는 것은 여전히 복잡하고 시간이 많이 소요될 수 있습니다. 두 프로토콜 모두 학습 곡선이 가파르며 보안을 보장하기 위해 신중한 구현이 필요합니다. 대신, 이러한 프로토콜을 지원하거나 기반으로 구축된 <Ref slug="identity-provider" />를 사용하면 인증 과정을 크게 단순화할 수 있습니다. 좋은 신원 제공자는 또한 <Ref slug="mfa" /> 및 <Ref slug="single-sign-on" />과 같은 추가 기능을 제공하여 미래의 요구를 충족할 수 있습니다.

## AuthZ와 AuthN의 차이점은 무엇인가요?

AuthN을 논의할 때, AuthZ도 자연스럽게 대화에 포함됩니다. 인증 (AuthN)은 비밀번호나 생체 인증과 같은 자격 증명을 통해 "당신은 누구인가?"라는 질문에 답하며 신원을 확인합니다. 권한 부여 (AuthZ)는 역할이나 정책에 따라 접근을 허용하거나 거부하여 "당신은 무엇을 할 수 있는가?"라는 질문에 답합니다. AuthN은 신원을 확인하기 위해 먼저 수행되며, AuthZ는 권한을 관리하기 위해 뒤따릅니다.

예를 들어, 사용자 이름과 비밀번호로 이메일 계정에 로그인할 때, 이는 **인증 (AuthN)**으로, 당신이 누구인지 증명하는 것입니다. 로그인 후, 시스템은 당신의 역할에 따라 이메일을 읽거나, 메시지를 보내거나, 관리자 설정에 접근할 수 있는지를 결정합니다. 이는 **권한 부여 (AuthZ)**로, 당신이 할 수 있는 일을 정의합니다.

<SeeAlso slugs={["authorization", "access-control", "openid-connect"]} />

<Resources
  urls={[
    "https://blog.logto.io/ciam-101-intro-authn-sso",
    "https://blog.logto.io/ciam-102-authz-and-rbac",
  ]}
/>
